// Code generated by go-swagger; DO NOT EDIT.

package types

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ContainerConfig Configuration for a container that is portable between hosts
// swagger:model ContainerConfig

type ContainerConfig struct {

	// Command is already escaped (Windows only)
	ArgsEscaped bool `json:"ArgsEscaped,omitempty"`

	// Whether to attach to `stderr`.
	AttachStderr *bool `json:"AttachStderr,omitempty"`

	// Whether to attach to `stdin`.
	AttachStdin *bool `json:"AttachStdin,omitempty"`

	// Whether to attach to `stdout`.
	AttachStdout *bool `json:"AttachStdout,omitempty"`

	// Command to run specified as a string or an array of strings.
	Cmd []string `json:"Cmd"`

	// The domain name to use for the container.
	Domainname string `json:"Domainname,omitempty"`

	// The entry point for the container as a string or an array of strings.
	// If the array consists of exactly one empty string (`[""]`) then the entry point is reset to system default (i.e., the entry point used by docker when there is no `ENTRYPOINT` instruction in the `Dockerfile`).
	//
	Entrypoint []string `json:"Entrypoint"`

	// A list of environment variables to set inside the container in the form `["VAR=value", ...]`. A variable without `=` is removed from the environment, rather than to have an empty value.
	//
	Env []string `json:"Env"`

	// An object mapping ports to an empty object in the form:`{<port>/<tcp|udp>: {}}`
	ExposedPorts map[string]interface{} `json:"ExposedPorts,omitempty"`

	// The hostname to use for the container, as a valid RFC 1123 hostname.
	Hostname string `json:"Hostname,omitempty"`

	// The name of the image to use when creating the container
	Image string `json:"Image,omitempty"`

	// User-defined key/value metadata.
	Labels map[string]string `json:"Labels,omitempty"`

	// MAC address of the container.
	MacAddress string `json:"MacAddress,omitempty"`

	// Disable networking for the container.
	NetworkDisabled bool `json:"NetworkDisabled,omitempty"`

	// `ONBUILD` metadata that were defined in the image's `Dockerfile`.
	OnBuild []string `json:"OnBuild"`

	// Open `stdin`
	OpenStdin *bool `json:"OpenStdin,omitempty"`

	// Shell for when `RUN`, `CMD`, and `ENTRYPOINT` uses a shell.
	Shell []string `json:"Shell"`

	// Close `stdin` after one attached client disconnects
	StdinOnce *bool `json:"StdinOnce,omitempty"`

	// Signal to stop a container as a string or unsigned integer.
	StopSignal *string `json:"StopSignal,omitempty"`

	// Timeout to stop a container in seconds.
	StopTimeout *int64 `json:"StopTimeout,omitempty"`

	// Attach standard streams to a TTY, including `stdin` if it is not closed.
	Tty *bool `json:"Tty,omitempty"`

	// The user that commands are run as inside the container.
	User string `json:"User,omitempty"`

	// volumes
	Volumes *ContainerConfigVolumes `json:"Volumes,omitempty"`

	// The working directory for commands to run in.
	WorkingDir string `json:"WorkingDir,omitempty"`
}

/* polymorph ContainerConfig ArgsEscaped false */

/* polymorph ContainerConfig AttachStderr false */

/* polymorph ContainerConfig AttachStdin false */

/* polymorph ContainerConfig AttachStdout false */

/* polymorph ContainerConfig Cmd false */

/* polymorph ContainerConfig Domainname false */

/* polymorph ContainerConfig Entrypoint false */

/* polymorph ContainerConfig Env false */

/* polymorph ContainerConfig ExposedPorts false */

/* polymorph ContainerConfig Hostname false */

/* polymorph ContainerConfig Image false */

/* polymorph ContainerConfig Labels false */

/* polymorph ContainerConfig MacAddress false */

/* polymorph ContainerConfig NetworkDisabled false */

/* polymorph ContainerConfig OnBuild false */

/* polymorph ContainerConfig OpenStdin false */

/* polymorph ContainerConfig Shell false */

/* polymorph ContainerConfig StdinOnce false */

/* polymorph ContainerConfig StopSignal false */

/* polymorph ContainerConfig StopTimeout false */

/* polymorph ContainerConfig Tty false */

/* polymorph ContainerConfig User false */

/* polymorph ContainerConfig Volumes false */

/* polymorph ContainerConfig WorkingDir false */

// Validate validates this container config
func (m *ContainerConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCmd(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateEntrypoint(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateEnv(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateExposedPorts(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateOnBuild(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateShell(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateVolumes(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ContainerConfig) validateCmd(formats strfmt.Registry) error {

	if swag.IsZero(m.Cmd) { // not required
		return nil
	}

	return nil
}

func (m *ContainerConfig) validateEntrypoint(formats strfmt.Registry) error {

	if swag.IsZero(m.Entrypoint) { // not required
		return nil
	}

	return nil
}

func (m *ContainerConfig) validateEnv(formats strfmt.Registry) error {

	if swag.IsZero(m.Env) { // not required
		return nil
	}

	return nil
}

// additional properties value enum
var containerConfigExposedPortsValueEnum []interface{}

func init() {
	var res []interface{}
	if err := json.Unmarshal([]byte(`[{}]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		containerConfigExposedPortsValueEnum = append(containerConfigExposedPortsValueEnum, v)
	}
}
func (m *ContainerConfig) validateExposedPortsValueEnum(path, location string, value interface{}) error {
	if err := validate.Enum(path, location, value, containerConfigExposedPortsValueEnum); err != nil {
		return err
	}
	return nil
}

func (m *ContainerConfig) validateExposedPorts(formats strfmt.Registry) error {

	if swag.IsZero(m.ExposedPorts) { // not required
		return nil
	}

	if swag.IsZero(m.ExposedPorts) { // not required
		return nil
	}

	for k := range m.ExposedPorts {

		if swag.IsZero(m.ExposedPorts[k]) { // not required
			continue
		}

	}

	return nil
}

func (m *ContainerConfig) validateOnBuild(formats strfmt.Registry) error {

	if swag.IsZero(m.OnBuild) { // not required
		return nil
	}

	return nil
}

func (m *ContainerConfig) validateShell(formats strfmt.Registry) error {

	if swag.IsZero(m.Shell) { // not required
		return nil
	}

	return nil
}

func (m *ContainerConfig) validateVolumes(formats strfmt.Registry) error {

	if swag.IsZero(m.Volumes) { // not required
		return nil
	}

	if m.Volumes != nil {

		if err := m.Volumes.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Volumes")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ContainerConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ContainerConfig) UnmarshalBinary(b []byte) error {
	var res ContainerConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ContainerConfigVolumes An object mapping mount point paths inside the container to empty objects.
// swagger:model ContainerConfigVolumes

type ContainerConfigVolumes struct {

	// additional properties
	AdditionalProperties interface{} `json:"additionalProperties,omitempty"`
}

/* polymorph ContainerConfigVolumes additionalProperties false */

// Validate validates this container config volumes
func (m *ContainerConfigVolumes) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAdditionalProperties(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var containerConfigVolumesTypeAdditionalPropertiesPropEnum []interface{}

func init() {
	var res []interface{}
	if err := json.Unmarshal([]byte(`[{}]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		containerConfigVolumesTypeAdditionalPropertiesPropEnum = append(containerConfigVolumesTypeAdditionalPropertiesPropEnum, v)
	}
}

// prop value enum
func (m *ContainerConfigVolumes) validateAdditionalPropertiesEnum(path, location string, value interface{}) error {
	if err := validate.Enum(path, location, value, containerConfigVolumesTypeAdditionalPropertiesPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *ContainerConfigVolumes) validateAdditionalProperties(formats strfmt.Registry) error {

	if swag.IsZero(m.AdditionalProperties) { // not required
		return nil
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ContainerConfigVolumes) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ContainerConfigVolumes) UnmarshalBinary(b []byte) error {
	var res ContainerConfigVolumes
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
