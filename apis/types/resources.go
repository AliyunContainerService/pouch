// Code generated by go-swagger; DO NOT EDIT.

package types

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Resources A container's resources (cgroups config, ulimits, etc)
// swagger:model Resources

type Resources struct {

	// Limit read rate (bytes per second) from a device, in the form `[{"Path": "device_path", "Rate": rate}]`.
	//
	BlkioDeviceReadBps []*ThrottleDevice `json:"BlkioDeviceReadBps"`

	// Limit read rate (IO per second) from a device, in the form `[{"Path": "device_path", "Rate": rate}]`.
	//
	BlkioDeviceReadIOps []*ThrottleDevice `json:"BlkioDeviceReadIOps"`

	// Limit write rate (bytes per second) to a device, in the form `[{"Path": "device_path", "Rate": rate}]`.
	//
	BlkioDeviceWriteBps []*ThrottleDevice `json:"BlkioDeviceWriteBps"`

	// Limit write rate (IO per second) to a device, in the form `[{"Path": "device_path", "Rate": rate}]`.
	//
	BlkioDeviceWriteIOps []*ThrottleDevice `json:"BlkioDeviceWriteIOps"`

	// Block IO weight (relative weight), need CFQ IO Scheduler enable.
	// Required: true
	// Maximum: 1000
	// Minimum: 0
	BlkioWeight uint16 `json:"BlkioWeight"`

	// Block IO weight (relative device weight) in the form `[{"Path": "device_path", "Weight": weight}]`.
	//
	BlkioWeightDevice []*WeightDevice `json:"BlkioWeightDevice"`

	// CPU CFS (Completely Fair Scheduler) period.
	// The length of a CPU period in microseconds.
	//
	// Required: true
	// Maximum: 1e+06
	// Minimum: 1000
	CPUPeriod int64 `json:"CPUPeriod"`

	// CPU CFS (Completely Fair Scheduler) quota.
	// Microseconds of CPU time that the container can get in a CPU period."
	//
	// Required: true
	// Minimum: 1000
	CPUQuota int64 `json:"CPUQuota"`

	// An integer value representing this container's relative CPU weight versus other containers.
	// Required: true
	CPUShares int64 `json:"CPUShares"`

	// Path to `cgroups` under which the container's `cgroup` is created. If the path is not absolute, the path is considered to be relative to the `cgroups` path of the init process. Cgroups are created if they do not already exist.
	// Required: true
	CgroupParent string `json:"CgroupParent"`

	// The number of usable CPUs (Windows only).
	// On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is `CPUCount` first, then `CPUShares`, and `CPUPercent` last.
	//
	// Required: true
	CPUCount int64 `json:"CpuCount"`

	// The usable percentage of the available CPUs (Windows only).
	// On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is `CPUCount` first, then `CPUShares`, and `CPUPercent` last.
	//
	// Required: true
	CPUPercent int64 `json:"CpuPercent"`

	// The length of a CPU real-time period in microseconds. Set to 0 to allocate no time allocated to real-time tasks.
	// Required: true
	CPURealtimePeriod int64 `json:"CpuRealtimePeriod"`

	// The length of a CPU real-time runtime in microseconds. Set to 0 to allocate no time allocated to real-time tasks.
	// Required: true
	CPURealtimeRuntime int64 `json:"CpuRealtimeRuntime"`

	// CPUs in which to allow execution (e.g., `0-3`, `0,1`)
	// Required: true
	CpusetCpus string `json:"CpusetCpus"`

	// Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on NUMA systems.
	// Required: true
	CpusetMems string `json:"CpusetMems"`

	// a list of cgroup rules to apply to the container
	// Required: true
	DeviceCgroupRules []string `json:"DeviceCgroupRules"`

	// A list of devices to add to the container.
	Devices []*DeviceMapping `json:"Devices"`

	// Maximum IO in bytes per second for the container system drive (Windows only)
	// Required: true
	IOMaximumBandwidth uint64 `json:"IOMaximumBandwidth"`

	// Maximum IOps for the container system drive (Windows only)
	// Required: true
	IOMaximumIOps uint64 `json:"IOMaximumIOps"`

	// IntelRdtL3Cbm specifies settings for Intel RDT/CAT group that the container is placed into to limit the resources (e.g., L3 cache) the container has available.
	// Required: true
	IntelRdtL3Cbm string `json:"IntelRdtL3Cbm"`

	// Kernel memory limit in bytes.
	// Required: true
	KernelMemory int64 `json:"KernelMemory"`

	// Memory limit in bytes.
	// Required: true
	Memory int64 `json:"Memory"`

	// MemoryExtra is an integer value representing this container's memory high water mark percentage.
	// The range is in [0, 100].
	//
	// Required: true
	// Maximum: 100
	// Minimum: 0
	MemoryExtra *int64 `json:"MemoryExtra"`

	// MemoryForceEmptyCtl represents whether to reclaim the page cache when deleting cgroup.
	// Required: true
	// Maximum: 1
	// Minimum: 0
	MemoryForceEmptyCtl int64 `json:"MemoryForceEmptyCtl"`

	// Memory soft limit in bytes.
	// Required: true
	MemoryReservation int64 `json:"MemoryReservation"`

	// Total memory limit (memory + swap). Set as `-1` to enable unlimited swap.
	// Required: true
	MemorySwap int64 `json:"MemorySwap"`

	// Tune a container's memory swappiness behavior. Accepts an integer between 0 and 100.
	// Required: true
	// Maximum: 100
	// Minimum: 0
	MemorySwappiness *int64 `json:"MemorySwappiness"`

	// MemoryWmarkRatio is an integer value representing this container's memory low water mark percentage.
	// The value of memory low water mark is memory.limit_in_bytes * MemoryWmarkRatio. The range is in [0, 100].
	//
	// Required: true
	// Maximum: 100
	// Minimum: 0
	MemoryWmarkRatio *int64 `json:"MemoryWmarkRatio"`

	// CPU quota in units of 10<sup>-9</sup> CPUs.
	// Required: true
	NanoCpus int64 `json:"NanoCPUs"`

	// Disable OOM Killer for the container.
	// Required: true
	OomKillDisable *bool `json:"OomKillDisable"`

	// Tune a container's pids limit. Set -1 for unlimited. Only on Linux 4.4 does this parameter support.
	//
	// Required: true
	PidsLimit int64 `json:"PidsLimit"`

	// ScheLatSwitch enables scheduler latency count in cpuacct
	// Required: true
	// Maximum: 1
	// Minimum: 0
	ScheLatSwitch int64 `json:"ScheLatSwitch"`

	// A list of resource limits to set in the container. For example: `{"Name": "nofile", "Soft": 1024, "Hard": 2048}`"
	//
	Ulimits []*Ulimit `json:"Ulimits"`
}

/* polymorph Resources BlkioDeviceReadBps false */

/* polymorph Resources BlkioDeviceReadIOps false */

/* polymorph Resources BlkioDeviceWriteBps false */

/* polymorph Resources BlkioDeviceWriteIOps false */

/* polymorph Resources BlkioWeight false */

/* polymorph Resources BlkioWeightDevice false */

/* polymorph Resources CPUPeriod false */

/* polymorph Resources CPUQuota false */

/* polymorph Resources CPUShares false */

/* polymorph Resources CgroupParent false */

/* polymorph Resources CpuCount false */

/* polymorph Resources CpuPercent false */

/* polymorph Resources CpuRealtimePeriod false */

/* polymorph Resources CpuRealtimeRuntime false */

/* polymorph Resources CpusetCpus false */

/* polymorph Resources CpusetMems false */

/* polymorph Resources DeviceCgroupRules false */

/* polymorph Resources Devices false */

/* polymorph Resources IOMaximumBandwidth false */

/* polymorph Resources IOMaximumIOps false */

/* polymorph Resources IntelRdtL3Cbm false */

/* polymorph Resources KernelMemory false */

/* polymorph Resources Memory false */

/* polymorph Resources MemoryExtra false */

/* polymorph Resources MemoryForceEmptyCtl false */

/* polymorph Resources MemoryReservation false */

/* polymorph Resources MemorySwap false */

/* polymorph Resources MemorySwappiness false */

/* polymorph Resources MemoryWmarkRatio false */

/* polymorph Resources NanoCPUs false */

/* polymorph Resources OomKillDisable false */

/* polymorph Resources PidsLimit false */

/* polymorph Resources ScheLatSwitch false */

/* polymorph Resources Ulimits false */

// Validate validates this resources
func (m *Resources) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlkioDeviceReadBps(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateBlkioDeviceReadIOps(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateBlkioDeviceWriteBps(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateBlkioDeviceWriteIOps(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateBlkioWeight(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateBlkioWeightDevice(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCPUPeriod(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCPUQuota(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCPUShares(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCgroupParent(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCPUCount(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCPUPercent(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCPURealtimePeriod(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCPURealtimeRuntime(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCpusetCpus(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCpusetMems(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDeviceCgroupRules(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDevices(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateIOMaximumBandwidth(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateIOMaximumIOps(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateIntelRdtL3Cbm(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateKernelMemory(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMemory(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMemoryExtra(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMemoryForceEmptyCtl(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMemoryReservation(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMemorySwap(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMemorySwappiness(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMemoryWmarkRatio(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateNanoCpus(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateOomKillDisable(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePidsLimit(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateScheLatSwitch(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateUlimits(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Resources) validateBlkioDeviceReadBps(formats strfmt.Registry) error {

	if swag.IsZero(m.BlkioDeviceReadBps) { // not required
		return nil
	}

	for i := 0; i < len(m.BlkioDeviceReadBps); i++ {

		if swag.IsZero(m.BlkioDeviceReadBps[i]) { // not required
			continue
		}

		if m.BlkioDeviceReadBps[i] != nil {

			if err := m.BlkioDeviceReadBps[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("BlkioDeviceReadBps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Resources) validateBlkioDeviceReadIOps(formats strfmt.Registry) error {

	if swag.IsZero(m.BlkioDeviceReadIOps) { // not required
		return nil
	}

	for i := 0; i < len(m.BlkioDeviceReadIOps); i++ {

		if swag.IsZero(m.BlkioDeviceReadIOps[i]) { // not required
			continue
		}

		if m.BlkioDeviceReadIOps[i] != nil {

			if err := m.BlkioDeviceReadIOps[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("BlkioDeviceReadIOps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Resources) validateBlkioDeviceWriteBps(formats strfmt.Registry) error {

	if swag.IsZero(m.BlkioDeviceWriteBps) { // not required
		return nil
	}

	for i := 0; i < len(m.BlkioDeviceWriteBps); i++ {

		if swag.IsZero(m.BlkioDeviceWriteBps[i]) { // not required
			continue
		}

		if m.BlkioDeviceWriteBps[i] != nil {

			if err := m.BlkioDeviceWriteBps[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("BlkioDeviceWriteBps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Resources) validateBlkioDeviceWriteIOps(formats strfmt.Registry) error {

	if swag.IsZero(m.BlkioDeviceWriteIOps) { // not required
		return nil
	}

	for i := 0; i < len(m.BlkioDeviceWriteIOps); i++ {

		if swag.IsZero(m.BlkioDeviceWriteIOps[i]) { // not required
			continue
		}

		if m.BlkioDeviceWriteIOps[i] != nil {

			if err := m.BlkioDeviceWriteIOps[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("BlkioDeviceWriteIOps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Resources) validateBlkioWeight(formats strfmt.Registry) error {

	if err := validate.Required("BlkioWeight", "body", uint16(m.BlkioWeight)); err != nil {
		return err
	}

	if err := validate.MinimumInt("BlkioWeight", "body", int64(m.BlkioWeight), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("BlkioWeight", "body", int64(m.BlkioWeight), 1000, false); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateBlkioWeightDevice(formats strfmt.Registry) error {

	if swag.IsZero(m.BlkioWeightDevice) { // not required
		return nil
	}

	for i := 0; i < len(m.BlkioWeightDevice); i++ {

		if swag.IsZero(m.BlkioWeightDevice[i]) { // not required
			continue
		}

		if m.BlkioWeightDevice[i] != nil {

			if err := m.BlkioWeightDevice[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("BlkioWeightDevice" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Resources) validateCPUPeriod(formats strfmt.Registry) error {

	if err := validate.Required("CPUPeriod", "body", int64(m.CPUPeriod)); err != nil {
		return err
	}

	if err := validate.MinimumInt("CPUPeriod", "body", int64(m.CPUPeriod), 1000, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("CPUPeriod", "body", int64(m.CPUPeriod), 1e+06, false); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateCPUQuota(formats strfmt.Registry) error {

	if err := validate.Required("CPUQuota", "body", int64(m.CPUQuota)); err != nil {
		return err
	}

	if err := validate.MinimumInt("CPUQuota", "body", int64(m.CPUQuota), 1000, false); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateCPUShares(formats strfmt.Registry) error {

	if err := validate.Required("CPUShares", "body", int64(m.CPUShares)); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateCgroupParent(formats strfmt.Registry) error {

	if err := validate.RequiredString("CgroupParent", "body", string(m.CgroupParent)); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateCPUCount(formats strfmt.Registry) error {

	if err := validate.Required("CpuCount", "body", int64(m.CPUCount)); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateCPUPercent(formats strfmt.Registry) error {

	if err := validate.Required("CpuPercent", "body", int64(m.CPUPercent)); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateCPURealtimePeriod(formats strfmt.Registry) error {

	if err := validate.Required("CpuRealtimePeriod", "body", int64(m.CPURealtimePeriod)); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateCPURealtimeRuntime(formats strfmt.Registry) error {

	if err := validate.Required("CpuRealtimeRuntime", "body", int64(m.CPURealtimeRuntime)); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateCpusetCpus(formats strfmt.Registry) error {

	if err := validate.RequiredString("CpusetCpus", "body", string(m.CpusetCpus)); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateCpusetMems(formats strfmt.Registry) error {

	if err := validate.RequiredString("CpusetMems", "body", string(m.CpusetMems)); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateDeviceCgroupRules(formats strfmt.Registry) error {

	if err := validate.Required("DeviceCgroupRules", "body", m.DeviceCgroupRules); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateDevices(formats strfmt.Registry) error {

	if swag.IsZero(m.Devices) { // not required
		return nil
	}

	for i := 0; i < len(m.Devices); i++ {

		if swag.IsZero(m.Devices[i]) { // not required
			continue
		}

		if m.Devices[i] != nil {

			if err := m.Devices[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("Devices" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Resources) validateIOMaximumBandwidth(formats strfmt.Registry) error {

	if err := validate.Required("IOMaximumBandwidth", "body", uint64(m.IOMaximumBandwidth)); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateIOMaximumIOps(formats strfmt.Registry) error {

	if err := validate.Required("IOMaximumIOps", "body", uint64(m.IOMaximumIOps)); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateIntelRdtL3Cbm(formats strfmt.Registry) error {

	if err := validate.RequiredString("IntelRdtL3Cbm", "body", string(m.IntelRdtL3Cbm)); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateKernelMemory(formats strfmt.Registry) error {

	if err := validate.Required("KernelMemory", "body", int64(m.KernelMemory)); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateMemory(formats strfmt.Registry) error {

	if err := validate.Required("Memory", "body", int64(m.Memory)); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateMemoryExtra(formats strfmt.Registry) error {

	if err := validate.Required("MemoryExtra", "body", m.MemoryExtra); err != nil {
		return err
	}

	if err := validate.MinimumInt("MemoryExtra", "body", int64(*m.MemoryExtra), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("MemoryExtra", "body", int64(*m.MemoryExtra), 100, false); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateMemoryForceEmptyCtl(formats strfmt.Registry) error {

	if err := validate.Required("MemoryForceEmptyCtl", "body", int64(m.MemoryForceEmptyCtl)); err != nil {
		return err
	}

	if err := validate.MinimumInt("MemoryForceEmptyCtl", "body", int64(m.MemoryForceEmptyCtl), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("MemoryForceEmptyCtl", "body", int64(m.MemoryForceEmptyCtl), 1, false); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateMemoryReservation(formats strfmt.Registry) error {

	if err := validate.Required("MemoryReservation", "body", int64(m.MemoryReservation)); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateMemorySwap(formats strfmt.Registry) error {

	if err := validate.Required("MemorySwap", "body", int64(m.MemorySwap)); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateMemorySwappiness(formats strfmt.Registry) error {

	if err := validate.Required("MemorySwappiness", "body", m.MemorySwappiness); err != nil {
		return err
	}

	if err := validate.MinimumInt("MemorySwappiness", "body", int64(*m.MemorySwappiness), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("MemorySwappiness", "body", int64(*m.MemorySwappiness), 100, false); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateMemoryWmarkRatio(formats strfmt.Registry) error {

	if err := validate.Required("MemoryWmarkRatio", "body", m.MemoryWmarkRatio); err != nil {
		return err
	}

	if err := validate.MinimumInt("MemoryWmarkRatio", "body", int64(*m.MemoryWmarkRatio), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("MemoryWmarkRatio", "body", int64(*m.MemoryWmarkRatio), 100, false); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateNanoCpus(formats strfmt.Registry) error {

	if err := validate.Required("NanoCPUs", "body", int64(m.NanoCpus)); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateOomKillDisable(formats strfmt.Registry) error {

	if err := validate.Required("OomKillDisable", "body", m.OomKillDisable); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validatePidsLimit(formats strfmt.Registry) error {

	if err := validate.Required("PidsLimit", "body", int64(m.PidsLimit)); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateScheLatSwitch(formats strfmt.Registry) error {

	if err := validate.Required("ScheLatSwitch", "body", int64(m.ScheLatSwitch)); err != nil {
		return err
	}

	if err := validate.MinimumInt("ScheLatSwitch", "body", int64(m.ScheLatSwitch), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("ScheLatSwitch", "body", int64(m.ScheLatSwitch), 1, false); err != nil {
		return err
	}

	return nil
}

func (m *Resources) validateUlimits(formats strfmt.Registry) error {

	if swag.IsZero(m.Ulimits) { // not required
		return nil
	}

	for i := 0; i < len(m.Ulimits); i++ {

		if swag.IsZero(m.Ulimits[i]) { // not required
			continue
		}

		if m.Ulimits[i] != nil {

			if err := m.Ulimits[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("Ulimits" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Resources) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Resources) UnmarshalBinary(b []byte) error {
	var res Resources
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
